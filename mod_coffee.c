/* 
**  mod_coffee.c -- Apache sample coffee module
**  [Autogenerated via ``apxs -n coffee -g'']
**
** http://httpd.apache.org/docs/trunk/developer/output-filters.html
** http://httpd.apache.org/docs/2.2/mod/mod_filter.html
*/ 

#include "httpd.h"
#include "http_config.h"
#include "http_protocol.h"
#include "http_log.h"
#include "ap_config.h"
#include "apr_strings.h"

#define OPTION_PRINT_DEBUG (1)
#define OPTION_PRINT_FILE  (2)

static const char FILTER_NAME[]="COFFEE";

static void *create_config(apr_pool_t *pool, char *x);
static void *merge_config(apr_pool_t *pool, void *in_base, void *in_add);
static void coffee_register_hooks(apr_pool_t *p);

typedef struct {
    int option;
} module_config;

typedef struct {
    int option;
    apr_bucket_brigade *singlebucket;
} filter_context;

static const command_rec commands_table[] = {
   AP_INIT_TAKE1("Coffee_LogOption", ap_set_int_slot, (void*)APR_OFFSETOF(module_config, option), OR_ALL, "Logging type"),
   {NULL}
};

/* Dispatch list for API hooks */
module AP_MODULE_DECLARE_DATA coffee_module = {
    STANDARD20_MODULE_STUFF, 
    create_config,         /* create per-dir    config structures */
    merge_config,          /* merge  per-dir    config structures */
    NULL,                  /* create per-server config structures */
    NULL,                  /* merge  per-server config structures */
    commands_table,        /* table of config file commands       */
    coffee_register_hooks  /* register hooks                      */
};

static void *create_config(apr_pool_t *pool, char *x) {
    return apr_pcalloc(pool, sizeof(module_config));
}

static void *merge_config(apr_pool_t *pool, void *in_base, void *in_add) {
    module_config *base = (module_config*)in_base;
    module_config *add = (module_config*)in_add;

    module_config *newconfig = apr_palloc(pool, sizeof(module_config));
    newconfig->option = base->option | add->option;

    return newconfig;
}

static void *init_context(ap_filter_t *f) {
    if ( !f->ctx ) {
        filter_context *context = f->ctx = apr_palloc(f->r->pool, sizeof(filter_context));

        module_config *config = ap_get_module_config(f->r->per_dir_config, &coffee_module);
        context->option = config->option;

        context->singlebucket = apr_brigade_create(f->r->pool, f->c->bucket_alloc);

    }

    return f->ctx;
}

static void logging(filter_context *context, request_rec *request, const char *format, ...) {
    va_list vargs;
    const char *message = NULL;

    va_start(vargs, format);
    message = apr_pvsprintf(request->pool, format, vargs);
    va_end(vargs);

    if ( context->option & OPTION_PRINT_FILE ) {
        ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, request, "%s", message); 
    }

    if ( context->option & OPTION_PRINT_DEBUG ) {
        printf("%s\n", message);
    }
}

static apr_status_t coffee_filter(ap_filter_t *f, apr_bucket_brigade *bb) {
    apr_status_t status = APR_SUCCESS;
    filter_context *context = (filter_context*)f->ctx;
    apr_bucket *b = NULL;
    apr_bucket *nextbucket = NULL;

    if ( context==NULL ) {
        context = init_context(f);
        apr_table_unset(f->r->headers_out, "Content-Length");
    }

    logging(context, f->r, "ENTERING coffee_filter");

    if ( APR_BRIGADE_EMPTY(bb) ) {
        return APR_SUCCESS;
    }

    for ( b = APR_BRIGADE_FIRST(bb);
          b != APR_BRIGADE_SENTINEL(bb); ) {
        nextbucket = APR_BUCKET_NEXT(b);

        if ( APR_BUCKET_IS_EOS(b) ) {
            logging(context, f->r, "Processing EOS bucket.");
        }
        else if ( APR_BUCKET_IS_METADATA(b) ) {
            logging(context, f->r, "Processing Metadata bucket.");
        }
        else if ( APR_BUCKET_IS_FLUSH(b) ) {
            logging(context, f->r, "Processing Flash bucket.");
        }
        else {
            logging(context, f->r, "Processing data bucket (len=%d)", (int)b->length);
        }

        APR_BUCKET_REMOVE(b);
        APR_BRIGADE_INSERT_TAIL(context->singlebucket, b);
        status = ap_pass_brigade(f->next, context->singlebucket);
        apr_brigade_cleanup(context->singlebucket);

        logging(context, f->r, "        ==> ap_pass_brigade returned %d", status);

        b = nextbucket;
    }

    logging(context, f->r, "LEAVING coffee_filter");

    return status;
}

static void coffee_register_hooks(apr_pool_t *p)
{ 
    // It's ok to use the 3rd parameter for init_context, but ap_init_context_func cannot be used
    // to update the value of Content-Length from. Content-Length should be updated from the
    // first call of handler. This means that we need to check the context is NULL or not
    // before the main loop in handler.  In this case, it's simpler to call init_context from
    // handler directly and not to use ap_init_context_func here.
    ap_register_output_filter(FILTER_NAME, coffee_filter, NULL, AP_FTYPE_RESOURCE);
}
